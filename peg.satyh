@require: list
@import: local-string
@import: ordmap
@import: intmap
@import: option
@import: ordering

module PEG : sig

  type 'a peg
  type 'a tagged-string

  val untag              : 'a tagged-string -> string
  val view-tagged-string : 'a tagged-string -> 'a option * string * ('a tagged-string) list
  val split-into-tags    : 'a tagged-string -> ('a option * string) list
  val compare-peg : ('a -> 'a -> Ordering.ordering) -> 'a peg -> 'a peg -> Ordering.ordering

  % val pp-peg-with     : ('a -> string) -> 'a peg -> string
  % val pp-peg          : 'a peg -> string
  val rule            : 'a -> 'a peg
  val epsilon         : 'a peg
  val fail            : 'a peg
  val lookahead       : 'a peg -> 'a peg
  val string          : string -> 'a peg
  val in-class        : string -> 'a peg
  val not-in-class    : string -> 'a peg
  val not-followed-by : 'a peg -> 'a peg
  val repeat-at-least : int -> 'a peg -> 'a peg
  val repeat-at-most  : int -> 'a peg -> 'a peg
  val any-char        : 'a peg
  val optional        : 'a peg -> 'a peg
  val many            : 'a peg -> 'a peg
  val some            : 'a peg -> 'a peg
  val memoised        : 'a peg -> 'a peg
  val choice          : 'a peg -> 'a peg -> 'a peg
  val choices         : ('a peg) list -> 'a peg
  val append          : 'a peg -> 'a peg -> 'a peg
  val cat             : ('a peg) list -> 'a peg
  val regexp          : string -> 'a peg

  val alpha           : 'a peg
  val digit           : 'a peg
  val alphanum        : 'a peg
  val eos             : 'a peg
  val eol             : 'a peg   % CR, LF or End-of-String
  val char-but        : 'a peg -> 'a peg
  val spaces          : 'a peg
  val spaces1         : 'a peg

  val peg-scan : ('a -> 'a -> Ordering.ordering)
              -> ('a -> 'a peg) -> 'a peg -> string -> ('a tagged-string * string) option

end = struct

  type 'a peg =
    NonTerminal   of 'a
  | AnyChar
  | Fail
  | Epsilon
  | Lookahead     of 'a peg
  | String        of string
  | InClass       of string
  | Optional      of 'a peg
  | Many          of 'a peg
  | Choice        of 'a peg * 'a peg
  | Append        of 'a peg * 'a peg
  | NotFollowedBy of 'a peg
  | RegExp        of string
  | Alpha
  | Digit
  | AlphaNum
  | EOS
  | Memoised      of 'a peg

  type 'a tagged-string =
       TagStr of 'a option * string * ('a tagged-string) list

  let untag | (TagStr(ma , str , lst)) = str

  let view-tagged-string
  | (TagStr(ma, str , lst)) = (ma, str, lst)

  let is-some s =
    match s with
    | Some(a) -> true
    | None    -> false

  let-rec split-into-tags
  | (TagStr(None, str, lst)) =
    let go l (b, rs) =
        let ls = split-into-tags l in
        let nontriv = LocalList.any (fun (a, b) -> is-some a) ls in 
        (b || nontriv , List.append ls rs)
    in
    let (q, bs) = LocalList.fold-right go (false, []) lst in
    if q then bs else [(None , str)]
  | (TagStr(Some(b), str, lst)) = [(Some(b), str)]

  let escape-onestep c =
    if string-same c (string-unexplode [9])
    then `\t`
    else if string-same c (string-unexplode [10])
    then `\n`
    else if string-same c (string-unexplode [13])
    then `\r`
    else if string-same c `.`
    then `\.`
    else c

  let-rec escape-specials-aux acc str =
    let len = string-length str in
    if len == 0
    then acc
    else
    let (c, rest) = LocalString.split-at 1 str
    in escape-specials-aux (acc ^ escape-onestep c) rest

  let empstr = LocalString.string-empty
  let escape-specials = escape-specials-aux 

  let eos = EOS
  let any-char = AnyChar
  let rule a = NonTerminal(a)
  let fail   = Fail
  let epsilon = Epsilon
  let string str = String(str)
  let in-class cls = InClass(cls)
  let lookahead p = Lookahead(p)
  let optional re = Optional(re)
  let many re = Many(re)
  let some re = Append(re , Many re)
  let memoised p = Memoised(p)
  let choice l r = Choice(l, r)
  let choices ps =
      match ps with
      | [] -> fail
      | ls -> LocalList.fold-right-1 choice ls
  let append l r = Append(l, r)
  let cat ps     = LocalList.fold-right append epsilon ps
  let not-followed-by pg = NotFollowedBy(pg)
  let not-in-class str = append (not-followed-by (in-class str)) any-char
  let eol = choice (in-class (string-unexplode [10 ; 13])) eos
  let alpha = Alpha
  let digit = Digit
  let alphanum = AlphaNum
  let-rec repeat-at-least n p =
    if n <= 0
    then many p
    else append p (repeat-at-least (n - 1) p)
  let-rec repeat-at-most n p =
    append (cat (LocalList.replicate n (optional p))) (not-followed-by p)
  let regexp re  = RegExp(re)
  let char-but p = append (not-followed-by p) any-char
  let spaces  = many (in-class (string-unexplode [9; 10; 12; 32]))
  let spaces1 = some (in-class (string-unexplode [9; 10; 12; 32]))

  let string-empty = string-unexplode []

  let-rec string-any p str =
    if string-length str == 0
    then false
    else if string-same p (string-sub str 0 1)
    then true
    else string-any p (string-sub str 1 (string-length str - 1))

  let-rec option-union
  | (None)    l = l
  | (Some(a)) r = Some(a)

  let unary-fixity  = 10
  let choice-fixity = 15
  let cat-fixity = 20
  let post-fixity = 30

  let paren show s = if show then `(` ^ s ^ `)` else s

  let (>>=) = Option.bind
  let (=<<) f a = Option.bind a f
  let (<&>) ma f = Option.fmap f ma

  let-rec pp-peg-with-prec
  | d pp (RegExp re)        = `/` ^ re ^ `/`
  | d pp (Alpha)            = `[a-zA-Z]`
  | d pp (Digit)            = `[0-9]`
  | d pp (AlphaNum)         = `\w`
  | d pp (NotFollowedBy(p)) = `(?!` ^ pp-peg-with-prec unary-fixity pp p ^ `)`
  | d pp (NonTerminal(b)) = `'` ^ pp b
  | d pp (AnyChar) = `.`
  | d pp (Fail) = `_|_`
  | d pp (Epsilon) = ` `
  | d pp (Lookahead p) = `(?=` ^ pp-peg-with-prec unary-fixity pp p ^ `)`
  | d pp (String str)  = str
  | d pp (InClass cls) = `[` ^ cls ^ `]` 
  | d pp (Optional p)  = pp-peg-with-prec post-fixity pp p ^ `?`
  | d pp (Many p)      = pp-peg-with-prec post-fixity pp p ^ `*`
  | d pp (Choice (p, q)) = paren (d > choice-fixity) (LocalString.join-strings `/` (List.map (pp-peg-with-prec choice-fixity pp) [p ; q]))
  | d pp (Append(l, r)) =
      paren (d > cat-fixity) (pp-peg-with-prec cat-fixity pp l ^  pp-peg-with-prec cat-fixity pp r)
  | d pp (EOS)      = `$`
  | d pp (Memoised(p)) = pp-peg-with-prec d pp p

  let pp-peg f = pp-peg-with-prec unary-fixity (fun r -> arabic (Option.from (-1) (f r)))

  let unwords = LocalString.unwords

  let lt = Ordering.lt
  let gt = Ordering.gt
  let eq = Ordering.eq
  let olex = Ordering.lex
  let compare-string = Ordering.compare Ordering.string
  let-rec compare-peg
  | cmp (NonTerminal b) (NonTerminal c) = cmp b c
  | cmp (NonTerminal b) k         = lt
  | cmp (AnyChar) (NonTerminal b) = gt
  | cmp (AnyChar) (AnyChar)       = eq
  | cmp (AnyChar) k               = lt
  | cmp (Fail) (NonTerminal b)    = gt
  | cmp (Fail) (AnyChar)          = gt
  | cmp (Fail) (Fail)             = eq
  | cmp (Fail) k                  = lt
  | cmp (Epsilon) (NonTerminal b) = gt
  | cmp (Epsilon) (AnyChar)       = gt
  | cmp (Epsilon) (Fail)          = gt
  | cmp (Epsilon) (Epsilon)       = eq
  | cmp (Epsilon) k               = lt
  | cmp (Lookahead p) (NonTerminal b) = gt
  | cmp (Lookahead p) (AnyChar)       = gt
  | cmp (Lookahead p) (Fail)          = gt
  | cmp (Lookahead p) (Epsilon)       = gt
  | cmp (Lookahead p) (Lookahead q)   = compare-peg cmp p q
  | cmp (Lookahead p) k               = lt
  | cmp (String s) (NonTerminal b) = gt
  | cmp (String s) (AnyChar)       = gt
  | cmp (String s) (Fail)          = gt
  | cmp (String s) (Epsilon)       = gt
  | cmp (String s) (Lookahead p)   = gt
  | cmp (String s) (String t)      = compare-string s t
  | cmp (String s) k               = lt
  | cmp (InClass cls) (NonTerminal b) = gt
  | cmp (InClass cls) (AnyChar)       = gt
  | cmp (InClass cls) (Fail)          = gt
  | cmp (InClass cls) (Epsilon)       = gt
  | cmp (InClass cls) (Lookahead p)   = gt
  | cmp (InClass cls) (String s)      = gt
  | cmp (InClass cls) (InClass dls) = compare-string cls dls
  | cmp (InClass cls) k               = lt
  | cmp (Optional p) (NonTerminal b) = gt
  | cmp (Optional p) (AnyChar) = gt
  | cmp (Optional p) (Fail) = gt
  | cmp (Optional p) (Epsilon) = gt
  | cmp (Optional p) (Lookahead q) = gt
  | cmp (Optional p) (String str) = gt
  | cmp (Optional p) (InClass cls) = gt
  | cmp (Optional p) (Optional q) = compare-peg cmp p q
  | cmp (Optional p) k = lt
  | cmp (Many p) (Memoised(q)) = lt
  | cmp (Many p) (EOS) = lt
  | cmp (Many p) (AlphaNum) = lt
  | cmp (Many p) (Digit) = lt
  | cmp (Many p) (Alpha) = lt
  | cmp (Many p) (RegExp re) = lt
  | cmp (Many p) (NotFollowedBy q) = lt
  | cmp (Many p) (Append(q, r)) = lt
  | cmp (Many p) (Choice(q, r)) = lt
  | cmp (Many p) (Many q) = compare-peg cmp p q
  | cmp (Many p) k = gt
  | cmp (Choice(l, r)) (Memoised(p)) = lt
  | cmp (Choice(l, r)) (EOS) = lt
  | cmp (Choice(l, r)) (AlphaNum) = lt
  | cmp (Choice(l, r)) (Digit) = lt
  | cmp (Choice(l, r)) (Alpha) = lt
  | cmp (Choice(l, r)) (RegExp re) = lt
  | cmp (Choice(l, r)) (NotFollowedBy q) = lt
  | cmp (Choice(l, r)) (Append(q, u)) = lt
  | cmp (Choice(l, r)) (Choice(s, t)) =
      Ordering.lex (compare-peg cmp) (compare-peg cmp) (l, r) (s, t)
  | cmp (Choice(l, r)) k = gt
  | cmp (Append(l, r)) (Memoised(p)) = lt
  | cmp (Append(l, r)) (EOS) = lt
  | cmp (Append(l, r)) (AlphaNum) = lt
  | cmp (Append(l, r)) (Digit) = lt
  | cmp (Append(l, r)) (Alpha) = lt
  | cmp (Append(l, r)) (RegExp re) = lt
  | cmp (Append(l, r)) (NotFollowedBy q) = lt
  | cmp (Append(l, r)) (Append(s, t)) =
      Ordering.lex (compare-peg cmp) (compare-peg cmp) (l, r) (s, t)
  | cmp (Append p) k = gt
  | cmp (NotFollowedBy p) (Memoised(q)) = lt
  | cmp (NotFollowedBy p) (EOS) = lt
  | cmp (NotFollowedBy p) (AlphaNum) = lt
  | cmp (NotFollowedBy p) (Digit) = lt
  | cmp (NotFollowedBy p) (Alpha) = lt
  | cmp (NotFollowedBy p) (RegExp re) = lt
  | cmp (NotFollowedBy p) (NotFollowedBy q) = compare-peg cmp p q
  | cmp (NotFollowedBy p) k = gt
  | cmp (RegExp p) (Memoised(q)) = lt
  | cmp (RegExp p) (EOS) = lt
  | cmp (RegExp p) (AlphaNum) = lt
  | cmp (RegExp p) (Digit) = lt
  | cmp (RegExp p) (Alpha) = lt
  | cmp (RegExp p) (RegExp q) = compare-string p q
  | cmp (RegExp p) k = gt
  | cmp (Alpha) (Memoised(q)) = lt
  | cmp (Alpha) (EOS) = lt
  | cmp (Alpha) (AlphaNum) = lt
  | cmp (Alpha) (Digit) = lt
  | cmp (Alpha) (Alpha) = eq
  | cmp (Alpha) k = gt
  | cmp (Digit) (Memoised(q)) = lt
  | cmp (Digit) (EOS) = lt
  | cmp (Digit) (AlphaNum) = lt
  | cmp (Digit) (Digit) = eq
  | cmp (Digit) k       = gt
  | cmp (AlphaNum) (Memoised(q)) = lt
  | cmp (AlphaNum) (EOS) = lt
  | cmp (AlphaNum) (AlphaNum) = eq
  | cmp (AlphaNum) k       = gt
  | cmp (EOS) (Memoised(q)) = lt
  | cmp (EOS) (EOS) = eq
  | cmp (EOS) k = gt
  | cmp (Memoised(p)) (Memoised(q)) = compare-peg cmp p q
  | cmp (Memoised(p)) k = gt

  let peg-ord ord = Ordering.from-compare (compare-peg ord)

  let allocates m =
    let go = (fun (k, (c, d)) n -> LocalList.length (OrdMap.keys (!d)) + n)
    in LocalList.fold-right go 0 (IntMap.to-list m)

  let peg-scan ord rules p text =
    let omap = OrdMap.ordmap (peg-ord ord) in
    let total-len = string-length text in
    let-mutable memo <- IntMap.empty in
    let nth k =
        (match IntMap.lookup k (!memo) with
        | None -> let-mutable d <- OrdMap.empty in
                  let cell = (string-sub text k (total-len - k), d, total-len == k) in
                  let () = memo <- IntMap.insert k cell (!memo)
                  in cell
        | Some(d) -> d
        )
    in 
    let-rec loop q n =
      let (input, d, at-eos) = nth n in
      let memoise f =
            (match OrdMap.lookup omap q (!d) with
            | None -> let ans = f () in
                      let () = d <- OrdMap.insert omap q ans (!d) in
                      ans
            | Some(tr) -> tr
            )
      in
      match q with
      | Memoised(p) -> memoise (fun () -> loop p n)
      | NonTerminal(b) ->
          memoise
          (fun () ->
          (match loop (rules b) n with
          | None -> None
          | Some(TagStr(m, str, chs), pos) -> Some(TagStr(Some(b), str, chs), pos)
          ))
      | Fail -> None
      | Epsilon -> Some(TagStr(None, string-empty, []), n)
      | EOS ->
          if at-eos
          then Some(TagStr(None, empstr, []), n)
          else None
      | RegExp re ->
           (match string-scan (regexp-of-string re) input with
           | Some(ans, rest) ->
             Some(TagStr(None, ans, []), n + string-length ans)
           | None -> None)
      | Many(p) ->
          if at-eos
          then Some(TagStr(None, string-empty, []), n)
          else
          (match loop p n with
          | None -> Some(TagStr(None, string-empty, []), n)
          | Some(c, pos) ->
            (match loop (Many(p)) pos with
            | None -> Some(TagStr(None, untag c, [c]), pos)
            | Some(TagStr(z, str, chs), pos2) ->
               Some(TagStr(None, untag c ^ str, c :: chs), pos2)
            ))
      | Choice(p, q) ->
          (match loop p n with
          | None -> loop q n
          | Some(tstr, pos) -> Some(TagStr(None, untag tstr, [tstr]), pos))
      | Optional(p) ->
          (match loop p n with
          | None -> Some(TagStr(None, string-empty, []), n)
          | Some(tstr, r) -> Some(TagStr(None, untag tstr, [tstr]), r)
          )
      | Alpha -> loop (regexp (`[a-zA-Z]`)) n
      | Digit -> loop (regexp (`[0-9]`)) n
      | AlphaNum -> loop (regexp (`[a-zA-Z0-9]`)) n
      | NotFollowedBy(p) ->
          (match loop p n with
          | None -> Some(TagStr(None, string-empty, []), n)
          | Some(x,z) -> None
          )
      | InClass(str) -> loop (regexp (`[` ^ str ^ `]`)) n
      | String(str) ->
          (let exp-len = string-length str in
          if total-len - n < exp-len
          then None
          else let lh = string-sub input 0 exp-len in
          if string-same lh str
          then Some(TagStr(None, str, []), (n + exp-len))
          else None)
      | AnyChar ->
          if at-eos
          then None 
          else let c = string-sub input 0 1
               in Some(TagStr(None, c, []), n + 1)
      | Lookahead(p) ->
          (match loop p n with
           | Some(tstr, r) -> Some(TagStr(None, string-empty, []), n)
           | None          -> None
           )
      | Append(l, r) ->
          (match loop l n with
          | None -> None
          | Some(t, pos) ->
             (match loop r pos with
             | None -> None
             | Some(s, pos2) -> Some(TagStr(None, untag t ^ untag s, [t; s]), pos2)
             )
          )
  in loop p 0 <&> (fun (tstr, pos) ->
       (let rest = string-sub text pos (total-len - pos) in
%        let () = display-message (unwords [`Allocated:`; arabic (allocates (!memo))]) in
        (tstr, rest)
       )
     )
end
