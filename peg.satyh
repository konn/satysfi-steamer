@require: list
@import: local-string
@import: hashmap
@import: intmap
@import: option
@import: hashable

module PEG : sig
  type 'a peg
  type 'a tagged-string

  val untag              : 'a tagged-string -> string
  val view-tagged-string : 'a tagged-string -> 'a option * string * ('a tagged-string) list
  val split-into-tags    : 'a tagged-string -> ('a option * string) list
  val peg-hasher         : 'a Hashable.hasher -> ('a peg) Hashable.hasher

  val rule            : 'a -> 'a peg
  val epsilon         : 'a peg
  val fail            : 'a peg
  val lookahead       : 'a peg -> 'a peg
  val string          : string -> 'a peg
  val in-class        : string -> 'a peg
  val not-in-class    : string -> 'a peg
  val not-followed-by : 'a peg -> 'a peg
  val repeat-at-least : int -> 'a peg -> 'a peg
  val repeat-at-most  : int -> 'a peg -> 'a peg
  val any-char        : 'a peg
  val optional        : 'a peg -> 'a peg
  val many            : 'a peg -> 'a peg
  val some            : 'a peg -> 'a peg
  val memoised        : 'a peg -> 'a peg
  val choice          : 'a peg -> 'a peg -> 'a peg
  val choices         : ('a peg) list -> 'a peg
  val append          : 'a peg -> 'a peg -> 'a peg
  val cat             : ('a peg) list -> 'a peg
  val regexp          : string -> 'a peg

  val alpha           : 'a peg
  val digit           : 'a peg
  val alphanum        : 'a peg
  val eos             : 'a peg
  val eol             : 'a peg   % CR, LF or End-of-String
  val char-but        : 'a peg -> 'a peg
  val spaces          : 'a peg
  val spaces1         : 'a peg

  val peg-scan : 'a Hashable.hasher
              -> ('a -> 'a peg) -> 'a peg -> string -> ('a tagged-string * string) option

end = struct

  type 'a peg =
    NonTerminal   of 'a
  | AnyChar
  | Fail
  | Epsilon
  | Lookahead     of 'a peg
  | String        of string
  | InClass       of string
  | Optional      of 'a peg
  | Many          of 'a peg
  | Choice        of 'a peg * 'a peg
  | Append        of 'a peg * 'a peg
  | NotFollowedBy of 'a peg
  | RegExp        of string
  | Alpha
  | Digit
  | AlphaNum
  | EOS
  | Memoised      of 'a peg

  type 'a tagged-string =
       TagStr of 'a option * string * ('a tagged-string) list

  let untag | (TagStr(ma , str , lst)) = str

  let view-tagged-string
  | (TagStr(ma, str , lst)) = (ma, str, lst)

  let is-some s =
    match s with
    | Some(a) -> true
    | None    -> false

  let-rec split-into-tags
  | (TagStr(None, str, lst)) =
    let go l (b, rs) =
        let ls = split-into-tags l in
        let nontriv = LocalList.any (fun (a, b) -> is-some a) ls in 
        (b || nontriv , List.append ls rs)
    in
    let (q, bs) = LocalList.fold-right go (false, []) lst in
    if q then bs else [(None , str)]
  | (TagStr(Some(b), str, lst)) = [(Some(b), str)]

  let escape-onestep c =
    if string-same c (string-unexplode [9])
    then `\t`
    else if string-same c (string-unexplode [10])
    then `\n`
    else if string-same c (string-unexplode [13])
    then `\r`
    else if string-same c `.`
    then `\.`
    else c

  let-rec escape-specials-aux acc str =
    let len = string-length str in
    if len == 0
    then acc
    else
    let (c, rest) = LocalString.split-at 1 str
    in escape-specials-aux (acc ^ escape-onestep c) rest

  let empstr = LocalString.string-empty
  let escape-specials = escape-specials-aux 

  let eos = EOS
  let any-char = AnyChar
  let rule a = NonTerminal(a)
  let fail   = Fail
  let epsilon = Epsilon
  let string str = String(str)
  let in-class cls = InClass(cls)
  let lookahead p = Lookahead(p)
  let optional re = Optional(re)
  let many re = Many(re)
  let some re = Append(re , Many re)
  let memoised p = Memoised(p)
  let choice l r = Choice(l, r)
  let choices ps =
      match ps with
      | [] -> fail
      | ls -> LocalList.fold-right-1 choice ls
  let append l r = Append(l, r)
  let cat ps     = LocalList.fold-right append epsilon ps
  let not-followed-by pg = NotFollowedBy(pg)
  let not-in-class str = append (not-followed-by (in-class str)) any-char
  let eol = choice (in-class (string-unexplode [10 ; 13])) eos
  let alpha = Alpha
  let digit = Digit
  let alphanum = AlphaNum
  let-rec repeat-at-least n p =
    if n <= 0
    then many p
    else append p (repeat-at-least (n - 1) p)
  let-rec repeat-at-most n p =
    append (cat (LocalList.replicate n (optional p))) (not-followed-by p)
  let regexp re  = RegExp(re)
  let char-but p = append (not-followed-by p) any-char
  let spaces  = many (in-class (string-unexplode [9; 10; 12; 32]))
  let spaces1 = some (in-class (string-unexplode [9; 10; 12; 32]))

  let string-empty = string-unexplode []

  let-rec string-any p str =
    if string-length str == 0
    then false
    else if string-same p (string-sub str 0 1)
    then true
    else string-any p (string-sub str 1 (string-length str - 1))

  let-rec option-union
  | (None)    l = l
  | (Some(a)) r = Some(a)

  let unary-fixity  = 10
  let choice-fixity = 15
  let cat-fixity = 20
  let post-fixity = 30

  let paren show s = if show then `(` ^ s ^ `)` else s

  let (>>=) = Option.bind
  let (=<<) f a = Option.bind a f
  let (<&>) ma f = Option.fmap f ma

  let-rec pp-peg-with-prec
  | d pp (RegExp re)        = `/` ^ re ^ `/`
  | d pp (Alpha)            = `[a-zA-Z]`
  | d pp (Digit)            = `[0-9]`
  | d pp (AlphaNum)         = `\w`
  | d pp (NotFollowedBy(p)) = `(?!` ^ pp-peg-with-prec unary-fixity pp p ^ `)`
  | d pp (NonTerminal(b)) = `'` ^ pp b
  | d pp (AnyChar) = `.`
  | d pp (Fail) = `_|_`
  | d pp (Epsilon) = ` `
  | d pp (Lookahead p) = `(?=` ^ pp-peg-with-prec unary-fixity pp p ^ `)`
  | d pp (String str)  = str
  | d pp (InClass cls) = `[` ^ cls ^ `]` 
  | d pp (Optional p)  = pp-peg-with-prec post-fixity pp p ^ `?`
  | d pp (Many p)      = pp-peg-with-prec post-fixity pp p ^ `*`
  | d pp (Choice (p, q)) = paren (d > choice-fixity) (LocalString.join-strings `/` (List.map (pp-peg-with-prec choice-fixity pp) [p ; q]))
  | d pp (Append(l, r)) =
      paren (d > cat-fixity) (pp-peg-with-prec cat-fixity pp l ^  pp-peg-with-prec cat-fixity pp r)
  | d pp (EOS)      = `$`
  | d pp (Memoised(p)) = pp-peg-with-prec d pp p

  let pp-peg f = pp-peg-with-prec unary-fixity (fun r -> arabic (Option.from (-1) (f r)))

  let unwords = LocalString.unwords

  let unit-hasher = Hashable.unit
  let hash-in-nth h m n i = Hashable.in-nth h m n i

  let peg-equal hasher =
    let eql = Hashable.equal hasher in
    let-rec loop p q =
      (match (p, q) with
      | (NonTerminal r, NonTerminal q) -> eql r q
      | (AnyChar, AnyChar) -> true
      | (Fail, Fail) -> true
      | (Epsilon, Epsilon) -> true
      | (Lookahead p, Lookahead q) -> loop p q
      | (String str, String ttr) -> string-same str ttr
      | (InClass c, InClass d) -> string-same c d
      | (Optional p, Optional q) -> loop p q
      | (Many p, Many q) -> loop p q
      | (Choice(l, r), Choice(s, t)) -> loop l s && loop r t
      | (Append(l, r), Append(s, t)) -> loop l s && loop r t
      | (NotFollowedBy p, NotFollowedBy q) -> loop p q
      | (RegExp re, RegExp se) -> string-same re se
      | (Alpha, Alpha) -> true
      | (Digit, Digit) -> true
      | (AlphaNum, AlphaNum) -> true
      | (EOS, EOS) -> true
      | (Memoised p, Memoised q) -> loop p q
      | (_, _) -> false
      )
    in loop

  let str-hasher = Hashable.string

  let-rec peg-hash
  | h (NonTerminal b) = hash-in-nth h 17 0 b
  | _ (AnyChar)       = hash-in-nth unit-hasher 17 1 ()
  | _ (Fail)          = hash-in-nth unit-hasher 17 2 ()
  | _ (Epsilon)       = hash-in-nth unit-hasher 17 3 ()
  | h (Lookahead p)   =
     hash-in-nth (Hashable.mk (peg-hash h) (peg-equal h)) 17 4 p
  | _ (String str)    = hash-in-nth str-hasher 17 5 str
  | _ (InClass str)   = hash-in-nth str-hasher 17 6 str
  | h (Optional p)    =
     hash-in-nth (Hashable.mk (peg-hash h) (peg-equal h)) 17 7 p
  | h (Many p)    =
     hash-in-nth (Hashable.mk (peg-hash h) (peg-equal h)) 17 8 p
  | h (Choice(p, q))    =
     let h2 = Hashable.mk (peg-hash h) (peg-equal h) in
     hash-in-nth (Hashable.product h2 h2) 17 9 (p, q)
  | h (Append(p, q))    =
     let h2 = Hashable.mk (peg-hash h) (peg-equal h) in
     hash-in-nth (Hashable.product h2 h2) 17 10 (p, q)
  | h (NotFollowedBy p)    =
     hash-in-nth (Hashable.mk (peg-hash h) (peg-equal h)) 17 11 p
  | _ (RegExp str)   = hash-in-nth str-hasher 17 12 str
  | _ (Alpha)         = hash-in-nth unit-hasher 17 13 ()
  | _ (Digit)         = hash-in-nth unit-hasher 17 14 ()
  | _ (AlphaNum)         = hash-in-nth unit-hasher 17 15 ()
  | _ (EOS)         = hash-in-nth unit-hasher 17 16 ()
  | h (Memoised p)    =
     hash-in-nth (Hashable.mk (peg-hash h) (peg-equal h)) 17 17 p

  let peg-hasher hasher = Hashable.mk (peg-hash hasher) (peg-equal hasher)

  let peg-scan hasher rules p text =
    let omap = HashMap.hashmap (peg-hasher hasher) in
    let total-len = string-length text in
    let-mutable memo <- IntMap.empty in
    let nth k =
        (match IntMap.lookup k (!memo) with
        | None -> let-mutable d <- HashMap.empty in
                  let cell = (string-sub text k (total-len - k), d, total-len == k) in
                  let () = memo <- IntMap.insert k cell (!memo)
                  in cell
        | Some(d) -> d
        )
    in 
    let-rec loop q n =
      let (input, d, at-eos) = nth n in
      let memoise f =
            (match HashMap.lookup omap q (!d) with
            | None -> let ans = f () in
                      let () = d <- HashMap.insert omap q ans (!d) in
                      ans
            | Some(tr) -> tr
            )
      in
      match q with
      | Memoised(p) -> memoise (fun () -> loop p n)
      | NonTerminal(b) ->
          memoise
          (fun () ->
          (match loop (rules b) n with
          | None -> None
          | Some(TagStr(m, str, chs), pos) -> Some(TagStr(Some(b), str, chs), pos)
          ))
      | Fail -> None
      | Epsilon -> Some(TagStr(None, string-empty, []), n)
      | EOS ->
          if at-eos
          then Some(TagStr(None, empstr, []), n)
          else None
      | RegExp re ->
           (match string-scan (regexp-of-string re) input with
           | Some(ans, rest) ->
             Some(TagStr(None, ans, []), n + string-length ans)
           | None -> None)
      | Many(p) ->
          if at-eos
          then Some(TagStr(None, string-empty, []), n)
          else
          (match loop p n with
          | None -> Some(TagStr(None, string-empty, []), n)
          | Some(c, pos) ->
            (match loop (Many(p)) pos with
            | None -> Some(TagStr(None, untag c, [c]), pos)
            | Some(TagStr(z, str, chs), pos2) ->
               Some(TagStr(None, untag c ^ str, c :: chs), pos2)
            ))
      | Choice(p, q) ->
          (match loop p n with
          | None -> loop q n
          | Some(tstr, pos) -> Some(TagStr(None, untag tstr, [tstr]), pos))
      | Optional(p) ->
          (match loop p n with
          | None -> Some(TagStr(None, string-empty, []), n)
          | Some(tstr, r) -> Some(TagStr(None, untag tstr, [tstr]), r)
          )
      | Alpha -> loop (regexp (`[a-zA-Z]`)) n
      | Digit -> loop (regexp (`[0-9]`)) n
      | AlphaNum -> loop (regexp (`[a-zA-Z0-9]`)) n
      | NotFollowedBy(p) ->
          (match loop p n with
          | None -> Some(TagStr(None, string-empty, []), n)
          | Some(x,z) -> None
          )
      | InClass(str) -> loop (regexp (`[` ^ str ^ `]`)) n
      | String(str) ->
          (let exp-len = string-length str in
          if total-len - n < exp-len
          then None
          else let lh = string-sub input 0 exp-len in
          if string-same lh str
          then Some(TagStr(None, str, []), (n + exp-len))
          else None)
      | AnyChar ->
          if at-eos
          then None 
          else let c = string-sub input 0 1
               in Some(TagStr(None, c, []), n + 1)
      | Lookahead(p) ->
          (match loop p n with
           | Some(tstr, r) -> Some(TagStr(None, string-empty, []), n)
           | None          -> None
           )
      | Append(l, r) ->
          (match loop l n with
          | None -> None
          | Some(t, pos) ->
             (match loop r pos with
             | None -> None
             | Some(s, pos2) -> Some(TagStr(None, untag t ^ untag s, [t; s]), pos2)
             )
          )
  in loop p 0 <&> (fun (tstr, pos) ->
       (let rest = string-sub text pos (total-len - pos) in
%        let () = display-message (unwords [`Allocated:`; arabic (allocates (!memo))]) in
        (tstr, rest)
       )
     )
end
