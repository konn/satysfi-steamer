@require: list
@import: local-string
@import: intmap
@import: option

module PEG : sig

  type 'a peg
  type 'a tagged-string

  val untag              : 'a tagged-string -> string
  val view-tagged-string : 'a tagged-string -> 'a option * string * ('a tagged-string) list
  val split-into-tags    : 'a tagged-string -> ('a option * string) list

  % val pp-peg-with     : ('a -> string) -> 'a peg -> string
  % val pp-peg          : 'a peg -> string
  val rule            : 'a -> 'a peg
  val epsilon         : 'a peg
  val fail            : 'a peg
  val lookahead       : 'a peg -> 'a peg
  val string          : string -> 'a peg
  val in-class        : string -> 'a peg
  val not-in-class    : string -> 'a peg
  val not-followed-by : 'a peg -> 'a peg
  val any-char        : 'a peg
  val optional        : 'a peg -> 'a peg
  val many            : 'a peg -> 'a peg
  val some            : 'a peg -> 'a peg
  val choice          : 'a peg -> 'a peg -> 'a peg
  val choices         : ('a peg) list -> 'a peg
  val append          : 'a peg -> 'a peg -> 'a peg
  val cat             : ('a peg) list -> 'a peg
  val regexp          : string -> 'a peg

  val alpha           : 'a peg
  val digit           : 'a peg
  val alphanum        : 'a peg
  val eos             : 'a peg
  val eol             : 'a peg   % CR, LF or End-of-String
  val char-but        : 'a peg -> 'a peg
  val spaces          : 'a peg
  val spaces1         : 'a peg

  val peg-scan : ('a -> int option)? -> ('a -> 'a peg) -> 'a peg -> string -> ('a tagged-string * string) option

end = struct

  type 'a peg =
    NonTerminal   of 'a
  | AnyChar
  | Fail
  | Epsilon
  | Lookahead     of 'a peg
  | String        of string
  | InClass       of string
  | Optional      of 'a peg
  | Many          of 'a peg
  | Choice        of 'a peg * 'a peg
  | Append        of 'a peg * 'a peg
  | NotFollowedBy of 'a peg
  | RegExp        of string
  | Alpha
  | Digit
  | AlphaNum
  | EOS

  type 'a tagged-string =
       TagStr of 'a option * string * ('a tagged-string) list

  let untag | (TagStr(ma , str , lst)) = str

  let view-tagged-string
  | (TagStr(ma, str , lst)) = (ma, str, lst)

  let is-some s =
    match s with
    | Some(a) -> true
    | None    -> false

  let-rec split-into-tags
  | (TagStr(None, str, lst)) =
    let go l (b, rs) =
        let ls = split-into-tags l in
        let nontriv = LocalList.any (fun (a, b) -> is-some a) ls in 
        (b || nontriv , List.append ls rs)
    in
    let (q, bs) = LocalList.fold-right go (false, []) lst in
    if q then bs else [(None , str)]
  | (TagStr(Some(b), str, lst)) = [(Some(b), str)]

  let escape-onestep c =
    if string-same c (string-unexplode [9])
    then `\t`
    else if string-same c (string-unexplode [10])
    then `\n`
    else if string-same c (string-unexplode [13])
    then `\r`
    else if string-same c `.`
    then `\.`
    else c

  let-rec escape-specials-aux acc str =
    let len = string-length str in
    if len == 0
    then acc
    else
    let (c, rest) = LocalString.split-at 1 str
    in escape-specials-aux (acc ^ escape-onestep c) rest

  let empstr = LocalString.string-empty
  let escape-specials = escape-specials-aux 

  let eos = EOS
  let any-char = AnyChar
  let rule a = NonTerminal(a)
  let fail   = Fail
  let epsilon = Epsilon
  let string str = String(str)
  let in-class cls = InClass(cls)
  let lookahead p = Lookahead(p)
  let optional re = Optional(re)
  let many re = Many(re)
  let some re = Append(re , Many re)
  let choice l r = Choice(l, r)
  let choices ps =
      match ps with
      | [] -> fail
      | ls -> LocalList.fold-right-1 choice ls
  let append l r = Append(l, r)
  let cat ps     = LocalList.fold-right append epsilon ps
  let not-followed-by pg = NotFollowedBy(pg)
  let not-in-class str = append (not-followed-by (in-class str)) any-char
  let eol = choice (in-class (string-unexplode [10 ; 13])) eos
  let alpha = Alpha
  let digit = Digit
  let alphanum = AlphaNum
  let regexp re  = RegExp(re)
  let char-but p = append (not-followed-by p) any-char
  let spaces  = many (in-class (string-unexplode [9; 10; 12; 32]))
  let spaces1 = some (in-class (string-unexplode [9; 10; 12; 32]))

  let string-empty = string-unexplode []

  let-rec string-any p str =
    if string-length str == 0
    then false
    else if string-same p (string-sub str 0 1)
    then true
    else string-any p (string-sub str 1 (string-length str - 1))

  let-rec option-union
  | (None)    l = l
  | (Some(a)) r = Some(a)

  let unary-fixity  = 10
  let choice-fixity = 15
  let cat-fixity = 20
  let post-fixity = 30

  let paren show s = if show then `(` ^ s ^ `)` else s

  let (>>=) = Option.bind
  let (=<<) f a = Option.bind a f
  let (<&>) ma f = Option.fmap f ma

  let-rec pp-peg-with-prec
  | d pp (RegExp re)        = `/` ^ re ^ `/`
  | d pp (Alpha)            = `[a-zA-Z]`
  | d pp (Digit)            = `[0-9]`
  | d pp (AlphaNum)         = `\w`
  | d pp (NotFollowedBy(p)) = `(?!` ^ pp-peg-with-prec unary-fixity pp p ^ `)`
  | d pp (NonTerminal(b)) = `'` ^ pp b
  | d pp (AnyChar) = `.`
  | d pp (Fail) = `_|_`
  | d pp (Epsilon) = ` `
  | d pp (Lookahead p) = `(?=` ^ pp-peg-with-prec unary-fixity pp p ^ `)`
  | d pp (String str)  = str
  | d pp (InClass cls) = `[` ^ cls ^ `]` 
  | d pp (Optional p)  = pp-peg-with-prec post-fixity pp p ^ `?`
  | d pp (Many p)      = pp-peg-with-prec post-fixity pp p ^ `*`
  | d pp (Choice (p, q)) = paren (d > choice-fixity) (LocalString.join-strings `/` (List.map (pp-peg-with-prec choice-fixity pp) [p ; q]))
  | d pp (Append(l, r)) =
      paren (d > cat-fixity) (pp-peg-with-prec cat-fixity pp l ^  pp-peg-with-prec cat-fixity pp r)
  | d pp (EOS)      = `$`

  let pp-peg f = pp-peg-with-prec unary-fixity (fun r -> arabic (Option.from (-1) (f r)))

  let unwords = LocalString.unwords

  let peg-scan ?:to-int rules p text =
    let index = Option.from (fun a -> None) to-int in
    let total-len = string-length text in
    let-mutable memo <- IntMap.empty in
    let nth k =
        (match IntMap.lookup k (!memo) with
        | None -> let-mutable d <- IntMap.empty in
                  let cell = (string-sub text k (total-len - k), d) in
                  let () = memo <- IntMap.insert k cell (!memo)
                  in cell
        | Some(d) -> d
        )
    in 
    let-rec loop q n =
      let call r k =
        (match index r with
        | None -> loop (rules r) k
        | Some(i) ->
            let (subs, d) = nth k in
            (match IntMap.lookup i (!d) with
            | None -> let ans = loop (rules r) k in
                      let () = d <- IntMap.insert i ans (!d) in
                      ans
            | Some(tr) -> tr
            )
        ) in
      let at-eos = n == total-len in
      let (input, dcell) = nth n in
      match q with
      | NonTerminal(b) ->
          (match call b n with
          | None -> None
          | Some(TagStr(m, str, chs), pos) -> Some(TagStr(Some(b), str, [TagStr(m, str, chs)]), pos)
          )
      | Fail -> None
      | Epsilon -> Some(TagStr(None, string-empty, []), n)
      | EOS ->
          if at-eos
          then Some(TagStr(None, empstr, []), n)
          else None
      | RegExp re ->
          (match string-scan (regexp-of-string re) input with
          | Some(ans, rest) ->
            Some(TagStr(None, ans, []), n + string-length ans)
          | None -> None)
      | Many(p) ->
          if at-eos
          then Some(TagStr(None, string-empty, []), n)
          else
          (match loop p n with
          | None -> Some(TagStr(None, string-empty, []), n)
          | Some(c, pos) ->
            (match loop (Many(p)) pos with
            | None -> Some(TagStr(None, untag c, [c]), pos)
            | Some(TagStr(z, str, chs), pos2) ->
               Some(TagStr(None, untag c ^ str, c :: chs), pos2)
            ))
      | Choice(p, q) ->
          (match loop p n with
          | None -> loop q n
          | Some(tstr, pos) -> Some(TagStr(None, untag tstr, [tstr]), pos))
      | Optional(p) ->
          (match loop p n with
          | None -> Some(TagStr(None, string-empty, []), n)
          | Some(tstr, r) -> Some(TagStr(None, untag tstr, [tstr]), r)
          )
      | Alpha ->    loop (regexp (`[a-zA-Z]`)) n
      | Digit ->    loop (regexp (`[0-9]`)) n
      | AlphaNum -> loop (regexp (`[a-zA-Z0-9]`)) n
      | NotFollowedBy(p) ->
          (match loop p n with
          | None -> Some(TagStr(None, string-empty, []), n)
          | Some(x,z) -> None
          )
      | InClass(str) ->
          if at-eos
          then None
          else let c = string-sub input 0 1
               in if string-any c str
               then Some(TagStr(None, c, []), n + 1)
               else None
      | String(str) ->
          let exp-len = string-length str in
          if total-len - n < exp-len
          then None
          else let lh = string-sub input 0 exp-len in
          if string-same lh str
          then Some(TagStr(None, str, []), (n + exp-len))
          else None
      | AnyChar ->
          if at-eos
          then None 
          else let c = string-sub input 0 1
               in Some(TagStr(None, c, []), n + 1)
      | Lookahead(p) ->
          (match loop p n with
           | Some(tstr, r) -> Some(TagStr(None, string-empty, []), n)
           | None          -> None
           )
      | Append(l, r) ->
          (match loop l n with
          | None -> None
          | Some(t, pos) ->
             (match loop r pos with
             | None -> None
             | Some(s, pos2) -> Some(TagStr(None, untag t ^ untag s, [t; s]), pos2)
             )
          )
  in loop p 0 <&> (fun (tstr, pos) ->
       (let rest = string-sub text pos (total-len - pos)
        in (tstr, rest)
       )
     )

end
