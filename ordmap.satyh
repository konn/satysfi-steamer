@import: local-list
@import: ordering

% Binary heap, implemented as AVL tree.
module OrdMap : sig
  type 'k 'v ordmap
  type 'k 'v ordmap-ops

  val ordmap    : 'k Ordering.ord -> 'k 'v ordmap-ops

  val insert      : 'k 'v ordmap-ops -> 'k -> 'v -> 'k 'v ordmap -> 'k 'v ordmap
  val insert-with : 'k 'v ordmap-ops -> ('v -> 'v -> 'v) -> 'k -> 'v -> 'k 'v ordmap -> 'k 'v ordmap
  val from-list   : 'k 'v ordmap-ops -> ('k * 'v) list -> 'k 'v ordmap
  val lookup      : 'k 'v ordmap-ops -> 'k -> 'k 'v ordmap -> 'v option

  val singleton : 'k -> 'v -> 'k 'v ordmap
  val empty     : 'k 'v ordmap
  val keys      : 'k 'v ordmap -> 'k list
  val to-list   : 'k 'v ordmap -> ('k * 'v) list
end = struct
  type 'k 'v ordmap =
  | Branch of (| height : int
               ; left   : 'k 'v ordmap
               ; key    : 'k
               ; value  : 'v
               ; right  : 'k 'v ordmap
               |)
  | Leaf

  type 'k 'v ordmap-ops =
    (| insert      : 'k -> 'v -> 'k 'v ordmap -> 'k 'v ordmap
     ; insert-with : ('v -> 'v -> 'v) -> 'k -> 'v -> 'k 'v ordmap -> 'k 'v ordmap
     ; from-list   : ('k * 'v) list -> 'k 'v ordmap
     ; lookup      : 'k -> 'k 'v ordmap -> 'v option
     |)

  let-rec height
  | (Leaf) = 0
  | (Branch v) = v#height

  let max a b = if a < b then b else a

  let fork xt z v yt =
    let h = max (height xt) (height yt) + 1
    in Branch (| height = h
               ; left = xt
               ; key = z
               ; value = v
               ; right = yt
               |)

  let unsafe-left
  | (Branch v) = v#left

  let unsafe-right
  | (Branch v) = v#right

  let unsafe-key
  | (Branch v) = v#key

  let unsafe-value
  | (Branch v) = v#value

  let-rec rotr
  | (Leaf) = Leaf
  | (Branch v) =
      let l = v#left in
      fork (unsafe-left l) (unsafe-key l) (unsafe-value l)
           (fork (unsafe-right l) v#key v#value
                 v#right)

  let-rec rotl
  | (Leaf) = Leaf
  | (Branch v) =
      let r = v#right in
      fork (fork v#left v#key v#value (unsafe-left r))
           (unsafe-key r)
           (unsafe-value r)
           (unsafe-right r)

  let-rec bias
  | (Leaf) = 0
  | (Branch(v)) = height v#left - height v#right

  let branch xt k v yt =
    let hl = height xt in
    let hr = height yt in
    if (hr + 1 < hl)
    then if bias xt < 0
         then rotr (fork (rotl xt) k v yt)
         else rotr (fork xt k v yt)
    else
    if hl + 1 < hr
    then if (0 < bias yt)
         then rotl (fork xt k v (rotr yt))
         else rotl (fork xt k v yt)
    else fork xt k v yt


  let ordmap ord =
    let (<<)    = Ordering.less-than ord in
    let compare = Ordering.compare ord in
    let case-ord = Ordering.case-lt-eq-gt in
    let-rec insert-with
    | f i a (Branch v) =
        case-ord ord i v#key
         (fun () -> branch (insert-with f i a v#left) v#key v#value v#right)
         (fun () -> branch v#left i (f v#value a) v#right)
         (fun () -> branch v#left v#key v#value (insert-with f i a v#right))
    | f i a (Leaf) = fork Leaf i a Leaf
    in
    let insert i a t = insert-with (fun a b -> b) i a t in
    let from-list = LocalList.fold-right (fun (k, v) -> insert k v) Leaf in
    let-rec lookup
    | i (Leaf) = None
    | i (Branch(v)) =
       case-ord ord i v#key 
        (fun () -> lookup i v#left)
        (fun () -> Some(v#value))
        (fun () -> lookup i v#right)
    in
    (| insert      = insert
     ; insert-with = insert-with
     ; from-list   = from-list
     ; lookup      = lookup
     |)

  let insert os      = os#insert
  let from-list os   = os#from-list
  let lookup os      = os#lookup
  let insert-with os = os#insert-with

  let-rec to-list
  | (Leaf)     = []
  | (Branch v) = LocalList.concat [to-list v#left; [(v#key , v#value)]; to-list v#right]

  let empty = Leaf
  let singleton i v = fork empty i v empty

  let-rec keys
  | (Leaf)     = []
  | (Branch v) = LocalList.concat [keys v#left; [v#key]; keys v#right]

end
